## List Comprehensions

### Q1: Couple

解题思路, 列表生成式结果可以多种操作

## Data Abstraction

假设我们有一个 **城市（city）** 的抽象数据类型（ADT）。每个城市包含 **名称（name）**、**纬度（latitude）** 和 **经度（longitude）**。

### **构造器（Constructor）**

- **`make_city(name, lat, lon)`**：创建一个城市对象，包含指定的名称、纬度和经度。

### **选择器（Selectors）**

用于获取城市的信息：

- **`get_name(city)`**：返回城市的名称。
- **`get_lat(city)`**：返回城市的纬度。
- **`get_lon(city)`**：返回城市的经度。

### **示例**

```
python


复制编辑
>>> berkeley = make_city('Berkeley', 122, 37)
>>> get_name(berkeley)
'Berkeley'
>>> get_lat(berkeley)
122
>>> new_york = make_city('New York City', 74, 40)
>>> get_lon(new_york)
40
```

所有的构造器和选择器函数都可以在实验文件（lab 文件）中找到。如果你对它们的实现方式感兴趣，可以查看代码。但数据抽象的核心思想是：**我们不需要关心数据类型的具体实现，而只需要知道如何使用它们！** 🚀



### Q2: Distance



### Q3: Closer city



### Q4: Don't violate the abstraction barrier!

### **关于抽象数据类型（ADT）的使用规范**

在编写使用 **ADT（抽象数据类型）** 的函数时，**应始终使用构造器（constructors）和选择器（selectors），而不是直接假设 ADT 的具体实现**。

如果直接访问数据的底层实现，而不是通过提供的 **构造器和选择器**，这就叫做**违反抽象屏障（abstraction barrier）**，我们应该 **避免这样做！**

### **如何检查你的代码是否违反了抽象屏障？**

即使你的 `distance` 和 `closer_city` 通过了 **doctest**，它们仍可能 **违反了抽象屏障**。你可以运行以下命令来检查你的代码是否符合数据抽象的规范：

```
bash


复制编辑
python3 ok -q check_city_abstraction
```

**🔍 `check_city_abstraction` 测试的原理：**

- 它会**替换 `city` ADT 的底层实现**，然后重新运行 `distance` 和 `closer_city` 的测试。
- **如果你正确使用了构造器和选择器**，那么代码应该依然能正常运行！
- **如果你的代码不通过测试**，说明你可能直接访问了 `city` 的内部数据结构，而没有使用提供的 `make_city`、`get_lat`、`get_lon` 和 `get_name`。



## Trees

### Q5: Finding Berries!

校园里的松鼠需要你的帮助！🐿️🌳 校园里有很多树，松鼠们想知道哪些树上长有 **莓果（berry）**。

请定义函数 **`berry_finder`**，该函数接收一棵 **树（tree）** 作为输入，**如果树的某个节点包含值 `'berry'`，则返回 `True`，否则返回 `False`**。

### **提示：**

- 你可以使用 **递归** 来遍历树的所有节点！
- **考虑使用 `for` 循环来递归地遍历每个子树（branches）**。



### Q6: Sprout leaves

定义一个函数 **`sprout_leaves`**，它接收一棵树 **`t`** 和一个叶子节点列表 **`leaves`**，并返回一棵 **新的树**。
新树与原树 **`t`** **相同**，但**原树的所有叶子节点**都会被**添加新的分支**（每个 `leaves` 里的值都会作为一个新分支）。

------

### **示例**

假设我们有如下树 **`t`**：

```
markdown


复制编辑
  1
 / \
2   3
    |
    4
```

用 `tree(1, [tree(2), tree(3, [tree(4)])])` 来表示。

如果调用：

```
python


复制编辑
sprout_leaves(t, [5, 6])
```

则返回的新树应该是：

```
markdown


复制编辑
       1
     /   \
    2     3
   / \    |
  5   6   4
         / \
        5   6
```

------

这个问题的核心是：

- **判断一个节点是否是叶子**（没有子节点）。
- **如果是叶子，就给它添加新的分支**（每个 `leaves` 里的元素都变成一个新子节点）。
- **如果不是叶子，递归处理它的子树**。



**构造树** 用 `tree(label, branches)`

### Q7: Don't violate the abstraction barrier!

###### ChatGPT 说：

**注意：如果你正确实现了 `berry_finder` 和 `sprout_leaves`，那么这个问题不需要额外编写代码！**

在编写使用 **ADT（抽象数据类型）** 的函数时，我们应该尽可能使用 **构造器（constructor）** 和 **选择器（selector）**，而不是假设 ADT 的底层实现。**依赖数据抽象的底层实现被称为“违反抽象屏障”（violating the abstraction barrier），这是我们要避免的！**

即使你的 `berry_finder` 和 `sprout_leaves` 通过了 `doctests`，也可能仍然违反了抽象屏障。要检查是否存在问题，可以运行以下命令：

```
css


复制编辑
python3 ok -q check_abstraction
```

**`check_abstraction` 的作用**：

- 这个测试函数 **会临时替换 `tree` 抽象的实现**，然后重新运行 `berry_finder` 和 `sprout_leaves` 的测试。
- **如果你的代码依赖于 `tree` 的具体实现（比如直接用 `list` 操作 `tree`）而不是使用构造器和选择器，那么测试就会失败**。

### **如何修复？**

如果你之前的测试都通过了，但 `check_abstraction` 失败了，解决方法很简单：

- **检查代码是否直接把 `tree` 作为 `list` 处理，例如 `t[0]` 或 `t[1:]`**，这些都是错误的。

- 用正确的构造器和选择器

  ：

  - **构造树** 用 `tree(label, branches)`
  - **获取根节点值** 用 `label(tree)`
  - **获取子树** 用 `branches(tree)`
  - **判断是否是叶子** 用 `is_leaf(tree)`

### **确保你的代码能够在所有实现下都正确运行**

通过 `check_abstraction` 的测试，**你的代码应该能够适用于不同的 `tree` 实现**，这样才能保证你的实现是正确的。

你可以运行 `python3 ok -q check_abstraction` 进行检查，然后再继续后面的任务



# Optional Questions

### Q8: Coordinates

**实现 `coords` 函数**，它接受以下参数：

- 一个函数 `fn`
- 一个序列 `seq`（列表）
- 一个下界 `lower` 和一个上界 `upper`

`coords` 返回一个**坐标对**的列表，每个坐标对是一个列表 `[x, fn(x)]`，满足以下条件：

1. `x` **必须是 `seq` 中的元素**。
2. `y = fn(x)` 的值 **必须在 `[lower, upper]` 之间（包含边界）**。

------

### **示例**

```python
>>> seq = [-4, -2, 0, 1, 3]
>>> fn = lambda x: x**2
>>> coords(fn, seq, 1, 9)
[[-2, 4], [1, 1], [3, 9]]
```

#### **解释**

1. `fn(-4) = 16`，超出范围 `[1,9]`，不选
2. `fn(-2) = 4`，**在范围内**，选 `[-2, 4]`
3. `fn(0) = 0`，超出范围 `[1,9]`，不选
4. `fn(1) = 1`，**在范围内**，选 `[1, 1]`
5. `fn(3) = 9`，**在范围内**，选 `[3, 9]`

最终结果是 `[[ -2, 4 ], [ 1, 1 ], [ 3, 9 ]]`。

------

### **要求**

- **只能写一行代码**
- **使用列表推导式**



### Q9: Riffle Shuffle

熟悉的**洗牌（riffle shuffle）**，指的是对一叠**偶数张**的牌（或序列）进行洗牌，使得新的排列方式如下：

- **第一张** → **中间的第一张** → **第二张** → **中间的第二张** → ...
- 即： `deck[0]` → `deck[n//2]` → `deck[1]` → `deck[n//2 + 1]` → `deck[2]` → `deck[n//2 + 2]` ...

**要求**：
使用**列表推导式**写出单行代码，实现这个**洗牌算法**。

### **提示**

- 你可以使用 

  ```
  k%2
  ```

   来

  判断索引是偶数还是奇数

  ：

  - `k%2 == 0` 时，从**前半部分**取元素 `deck[k//2]`
  - `k%2 == 1` 时，从**后半部分**取元素 `deck[n//2 + k//2]`



### Q10: Add trees

定义函数 **`add_trees`**，该函数接受两棵树作为输入，并返回一棵新的树。新的树的每个节点的值是**对应位置**的两个输入树的节点值相加得到的。

如果某个位置的节点**只在其中一棵树中存在**，那么它应该**直接出现在新树中**。

你可以使用 Python 内置的 `zip` 函数**同时遍历**两棵树的子节点列表。

递归地处理子树，确保所有节点都正确合并。



`zip()` 是 Python 内置的函数，用于**将多个可迭代对象（如列表、元组、字符串）按对应位置配对**，返回一个 **迭代器**，其中每个元素是一个元组。

```python
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']

zipped = zip(list1, list2)  # 返回一个迭代器
print(list(zipped))  # [(1, 'a'), (2, 'b'), (3, 'c')]
```

💡 **解释**：

- `zip(list1, list2)` **按索引对应**，将 `1` 和 `'a'`，`2` 和 `'b'`，`3` 和 `'c'` 组成 **元组** `(1, 'a')` 等。



#### **不同长度的列表**

如果输入的列表长度不同，`zip()` **会按照最短的列表** 进行配对，**多余的部分会被丢弃**：

```
python


复制编辑
list1 = [1, 2, 3, 4]
list2 = ['a', 'b']

print(list(zip(list1, list2)))  # [(1, 'a'), (2, 'b')]
```

📌 **如何保留所有数据？** ➜ 用 `itertools.zip_longest()`

```
python


复制编辑
from itertools import zip_longest

list1 = [1, 2, 3, 4]
list2 = ['a', 'b']

print(list(zip_longest(list1, list2, fillvalue='X')))  
# [(1, 'a'), (2, 'b'), (3, 'X'), (4, 'X')]
```

💡 `fillvalue='X'` 用 `'X'` 填充缺失值。



## Fun Question!

### **莎士比亚与字典**

我们将使用**字典（dictionaries）**来模拟莎士比亚的全部作品！

我们将使用 **二元语法（bigram）语言模型**。其核心思想如下：

- 假设我们从某个单词开始，例如 `"The"`。
- 然后，我们遍历莎士比亚所有的文本，并**记录每次 `"The"` 出现时后面接的单词**，把这些单词存入一个列表，称为 `"The"` 的 **后继单词列表（successors）**。
- 假如我们对莎士比亚用过的**每一个单词**都完成了这个过程，就能得到一个**后继表（successor table）**。



### Q11: Successor Tables

下面是 **`build_successors_table`** 函数的一个未完成定义。

- **输入**：一个 **单词列表**（代表莎士比亚文本中的所有单词）。
- **输出**：一个 **后继表（successors table）**，即一个字典，记录每个单词的后继单词列表。
- **默认规则**：句号 `'.'` 的后继单词是文本的第一个单词。



### Q12: Construct the Sentence



### **让我们生成一些句子吧！**

假设我们有一个**起始单词**，我们可以在**后继表（successors table）\**中查找它的后继单词列表，并\**随机选择**其中的一个单词作为句子的下一个单词。然后，我们重复这个过程，直到遇到某个**终止标点符号**（如 `'.'`、 `'?'` 或 `'!'`）。

### **提示**

- 随机选择列表中的一个单词：

  ```
  import random  
  random.choice(my_list)  # 从列表 my_list 中随机选择一个元素
  ```

- **字符串拼接**：可以使用 `+` 来拼接字符串，从而构造完整的句子。

### **你的任务**

请填充 `construct_sent` 函数的缺失部分，使其能够根据后继表**随机生成莎士比亚风格的句子**



### Putting it all together

太棒了！🎉 现在让我们尝试用**真实数据**运行我们的函数。

代码框架中包含了以下代码片段，它将返回一个**包含莎士比亚所有作品中的单词**的列表。

⚠️ **警告**：不要尝试直接打印该函数的返回结果，否则可能会导致大量输出，影响程序运行！

### **运行代码并构建 `successors table`**

取消注释以下两行代码，以生成莎士比亚语料的**单词列表**并构建**后继表**：

### **尝试生成随机莎士比亚风格的句子**

在 Python 交互模式（使用 `-i` 选项）中加载你的代码，然后调用 `random_sent()` 试试看！



网页已经无法访问了