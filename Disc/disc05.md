## Trees

### 专业概念

• **父节点（Parent node）**：具有分支的节点。父节点可以有多个分支。

• **子节点（Child node）**：具有父节点的节点。一个子节点只能属于**一个**父节点。

• **根节点（Root）**：树的最顶部节点。在我们的示例中，包含 **7** 的节点是根节点。

• **标签（Label）**：节点的值。在我们的示例中，所有整数都是节点的值。

• **叶子节点（Leaf）**：没有分支的节点。在我们的示例中，包含 **−4、0、6、17 和 20** 的节点都是叶子节点。

• **分支（Branch）**：根节点的一个子树。注意，树的分支本身也是**树**，这就是为什么**树是一种递归数据结构**。

• **深度（Depth）**：某个节点距离根节点的远近。换句话说，它是从**根节点到该节点之间的边数**。例如，在示例中，包含 **19** 的节点的深度是 **1**，包含 **3** 的节点的深度是 **2**。由于根节点到自身之间没有边，所以**根节点的深度是 0**。

• **高度（Height）**：**最深的叶子节点的深度**。在示例中，包含 **−4、0、6 和 17** 的节点是“最深的叶子节点”，它们的深度是 **4**。因此，这棵树的**高度为 4**。

## Implementation

## Questions

### 1.1

求树的高度，最长的 root 到 leaf 的路径长度



### 1.2

编写一个函数，该函数接受一棵树作为输入，并返回树中**从根到任意叶子节点的路径**上的**最大值总和**。请记住，路径是从树的根到任意叶子节点的序列。



### 1.3

编写一个函数，该函数接受一棵树并将树中每个节点的值平方。它应返回一棵新的树。你可以假设树中的每个值都是数字。



### 1.4

编写一个函数，该函数接收一棵 **树** 和一个值 `x`，返回从 **根节点** 到 **值为 x 的节点** 之间的所有节点（按照路径顺序）的列表。

如果 `x` **不在树中**，则返回 `None`。假设树中的所有值是**唯一的**。





## 2 Binary Numbers

### 2.1

### 2.2

编写一个函数，该函数接受一个**仅由 '0' 和 '1' 组成的树** `t`，以及一个**二进制数列表** `nums`，返回一个**新树**，其中仅包含 `nums` 中**存在于 `t` 的二进制数**。

**定义：**

- 每个**二进制数**是一个字符串（如 `"01"`、`"110"`）。
- 如果 `t` 中**存在从根到叶子的某条路径**，其值与 `n` 相同，则 `n` 存在于 `t` 中。
- 如果 `nums` 中**没有任何数存在于 `t`**，则返回 `None`。